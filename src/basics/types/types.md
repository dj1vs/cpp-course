# Типы данных [в разработке]

C++ - это *сильно типизированный* язык. Это означает, что у каждой переменной, у каждой функции, и так далее, должен быть явно указан её тип. Если компилятор не понимает, какой у переменной тип, он просто откажется компилировать программу..

Поэтому очень важно понимать, какие типы есть в С++ и как с ними работать.

## Что такое тип?
Справедливый вопрос, который зачастую не обговаривается (а зря).

Обсудим это на примере переменной.

**Тип** - это *свойство* переменной, которое определяет:
1. Операции, которые можно совершать над переменной (например, основные арифметические операции для целых чисел)
2. Набор значений, которые может принимать переменная данного типа.  Например, *обычно* переменная типа `int` может принимать значения от -2 147 483 647 до 2 147 483 647. Или, например, булева переменная (`bool`) может принимать значение только `true` или `false`

Пример того, как мы указываем тип в C++:
1. При создании функций
```cpp
int sum(int a, int b)
{
	return a + b;
}
```
Здесь мы чётко указали, что функция с именем `sum` принимает на вход два целых числа и как результат выполнения тоже возвращает целое число
2. При объявлении переменных
```cpp
std::string name;
```
Здесь мы чётко указали, что переменная с именем `name` имеет тип `std::string` (то есть, это строка).

## Переменные в памяти компьютера
Вообще, оперативную (да и в общем) память компьютера упрощённо можно представить как бесконечную ленту из 0 и 1:
```
01010101000100100011110100101010010101010...
```
Какая-то часть этой "ленты" используется запущеными приложениями, какая-то нет.

Итак, предположим, что у нас в памяти компьютера по какому-то адресу лежит переменная.Это будет выглядеть примерно так:
```
...[10011101]...
```
То есть, у нас выделен определённый фрагмент, в который потом записали обозначенные данные.

И без *типа* данных вот эта последовательность нулей и единиц (бит) не имеет **никакого смысла**. Может быть, тут зашифрован символ в какой-то кодировке. Может, здесь зашифровано целое число. А может дробное. А может это вообще какой-то специальный крутой шифр, в котором закодирован пароль запуска ядерных боеголовок - мы не знаем. В такой ситуации, эти данные для нас только мусор.

**Тип данных** наделяет эту последовательность бит *смыслом*, и определяет то, как с этими данными можно работать. Это важно и для пользователя, который будет работать с переменной, и для компьютера, который будет выполнять над этими данными какие-то машинные операции (переместить в регистр/сложить с другим регистром/скопировать значение в другую область памяти/...).

## Какие в С++ бывают типы?
> [!quote] Страуструп Б. - Программирование. Принципы и практика с использованием C++
> В языке С++ предусмотрен довольно широкий выбор типов (см. раздел А.8). Однако можно создавать прекрасные программы, обходясь лишь пятью из них.
> ```cpp
> int number_of_steps = 39; // int - для целых чисел
> double flyinq_time = 3.5; // double - для чисел с плавающей точкой
> char decimal_point = '.'; // char - для СИМВ ОЛОВ
> string name = "Annemarie"; // string - для строк
> bool tap_on = true ; // bool - для логических переменных

Но всё же, рассмотрим представленные в C++ типы чуть подробнее.

### Общее деление типов
[Выдержка из официальной документации](https://ru.cppreference.com/w/cpp/language/type)

Глобально, типы в C++ делятся на:
1. Фундаментальные - совсем простые типы, без которых никуда не деться (`int`, `char`, `double`, ...)
2. Составные - типы, которые, по сути, строятся на основе фундаментальныех
### Фундаментальные типы
Фундаментальные типы - это самые простые типы языка C++, которые служат "кирпичиками" для построения более сложных, составных типов.
#### Целые числа (int)
Целые числа в С++ задаются ключевым словом `int`. Пример:
```cpp
int a = 1; // a - целое число
```

##### Вычисление границ инта 
*Обычно*, переменная `int` занимает 4 байта.

В памяти целое число хранится просто в виде его представления в двоичной системе счисления.
Например, число `5` в памяти будет хранится как `101`.

Из этого следует, что мы можем посчитать, какое максимальное число можно уместить в переменной типа `int`:
- 4 байта - это $4 \times 8$ = 32 бит
- Целое число может быть и отрицательным - поэтому 1 бит уходит на хранение знака числа (Если первый бит - 1, то число отрицательное, 0 - положительное). Итого на хранение *самого числа* остаётся 31 бит.
- 31 бит соответствует числу в двоичной системе счисления, которое может состоять максимум из 31-го символа.
- Максимальное десятичное число, которое в двоичной системе счисления будет занимать *не больше 31-го символа* можно вычислить как:
$$
x = 2^{31} - 1 = \text{2 147 483 648} - 1 = \text{2 147 483 647}
$$

Получается, что целые числа (с учётом знаковости) могут принимать значения *от -2147483647 до 2147483647*.

##### Спецификаторы типа

Для типа `int` можно задавать *спецификаторы типа* - это специальные ключевые слова, которые *уточняют* тип переменной `int`. Давайте разберёмся, какие они бывают.
1. Уточняющие *знаковость* целового числа (может ли число быть положительным или нет) - `signed` и `unsigned`. `int` по умолчанию `signed`.
2. Уточняющие *размер* числа - `short`, `long`, `long long`. Так мы можем определить, с насколько большим целым числом мы хотим работать (и, соответственно, сколько памяти нужно выделять для хранения этого числа).

Если число будет *беззнаковое* (`unsigned`), то в нём для хранения *самого числа* выделяется уже не 31, а 32 бита (так как отдельный бит для хранения знака уже не нужен). Получается, числа `unsigned int` могут лежать в пределах от `0` до $2^{32} - 1 = \text{4 294 967 296} - 1 = \text{4 294 967 296}$.

По поводу размеров `int` *обычно* работает следующая шкала:
- `short int` - 2 байта
- `int` занимает 4 байта
- `long int` - 8 байт
- `long long int` - 16 байт

Для этих типов диапазоны значений высчитываются аналогично. При желании, их можно самому легко посчитать в калькуляторе, или банально нагуглить.

...с помощью спецификаторов можно задавать переменные типа `int` самыми разными способами:
```cpp
int a;
short int b;
short c;
long d;
long long e;
signed int f;
unsigned int g;
unsigned long long int h;
// и т.д.
```
То есть, можно как угодно сочетать спецификаторы, определяющие размер и знаковость числа. Так же можно опускать при определении типа слово `int`, если уже используется, например, `long long` или `signed`.
##### *Реальный* размер инта
Очень тонкий момент заключается в *размере `int`*. Да, *обычно*, размеры `int` такие, как я написал. Но это только обычно, а не всегда. На самом деле, размер `int` может различаться на разных платформах! Это определяется разрядностью и архитектурой процессора, и другими особенностями. Если взглянуть в [официальную документацию C++,](https://ru.cppreference.com/w/cpp/language/types) то размеры `int` там определены следующим образом:
![[cppreference_int_boundaries_ru.png]]
Обратите внимание на словосочетание: "не меньше чем"! То есть язык С++ не гарантирует точный размер переменной типа `int`, а только гарантирует, что она будет не меньше какого-то размера! По таким ограничениям, `short int` может быть такого же размера, как `int`.

Почему же существует такая путаница и неразбериха? Потому что C++ позволяет очень "близко" (*на низком уровне*) работать с целевой машиной, на которой работает программа. Поэтому такой базовый тип, как `int`, и зависит от особенностей конкретного компьютера, на котором будет собрана и запущена программа.

Но всё не так плохо! Если мы захотим, мы можем создать переменную `int`, которая будет ровно того размера, который нам нужен.

Чтобы чётко указать компилятору, что мы хотим переменную `int` размером в столько-то байт, существуют специальные типы:
```cpp
int32_t a; // Переменная signed int размером 32 бита (4 байта)
int8_t b; // Переменная signed int размером 8 бит (1 байт)
uint16_t c; // Переменная unsigned int размером 16 бит (2 байта)
```

На самом деле, это не отдельные типы, а просто заранее определённые `typedef`-псевдонимы. Они на этапе "подгоняются" под целевую машину, и, например, вместо `int16_t` на этапе компиляции может подставиться `short int`. Что такое `typedef`, мы разберём подробнее позже.
#### Дробные числа
Для хранения дробных чисел в C++ используется 3 типа данных:
- `float`
- `double`
- `long double`

С целыми числами все понятно, как они хранятся в памяти: это просто последовательность бит, которая в двоичной системе соответствует целому числу. Последовательность бит `10` означает $2_{10}$, `11` - $3_{10}$, и так далее.

Хранить же дробное число, так же как и выполнять с ним какие-то операции, на уровне бинарной арифметики, достаточно сложно и неудобно. Отсюда зачастую можно встретиться вот с таким интересным поведением программ (и не только на языке C++):
```cpp
float f = 0.6;
std::cout << (f/2  == 0.3); // 0
```

Здесь же скажем коротко: существуют специальные стандарты, которые определяют, как в компьютере будет храниться дробное число, и которые определяют допустимый размер дробного числа. 

Выдержка из документации касательно стандартов представления дробных чисел:

> [!quote] cppreference.com
> - float - тип с плавающей запятой одинарной точности. Соответствует [формату IEEE-754 binary32](https://tftwiki.ru/wiki/Single-precision_floating-point_format), если поддерживается.
> - double - тип с плавающей запятой двойной точности. Соответствует [формату IEEE-754 binary64](https://tftwiki.ru/wiki/Double-precision_floating-point_format), если поддерживается.
> - long double - тип с плавающей запятой повышенной точности. Соответствует [формату IEEE-754 binary128](https://datewiki.ru/wiki/Quadruple-precision_floating-point_format), если поддерживается, в противном случае соответствует [IEEE-754 binary64-расширенному формату](https://star-wiki.ru/wiki/Extended_precision), если поддерживается, иначе соответствует некоторому расширенному формату с плавающей запятой, отличному от IEEE-754, если его точность лучше, чем binary64, и диапазон не менее хорош как binary64, иначе соответствует формату IEEE-754 binary64.

Размеры для этих типов распределяются так:
- float: представляет вещественное число одинарной точности с плавающей точкой в диапазоне +/- 3.4E-38 до 3.4E+38. В памяти занимает 4 байта (32 бита)    
- double: представляет вещественное число двойной точности с плавающей точкой в диапазоне +/- 1.7E-308 до 1.7E+308. В памяти занимает 8 байт (64 бита)   
- long double: представляет вещественное число двойной точности с плавающей точкой не менее 8 байт (64 бит). В зависимости от размера занимаемой памяти может отличаться диапазон допустимых значений
## Символьный тип
Для представления символов в C++ используется тип *char*.

В целом символы `char` в языке C++ обозначаются так:
```cpp
char a = 'D';
```

Обратите внимание, что символы в С++ обозначаются *именно одинарными кавычками*, в отличие от *строк*, которые обозначаются *двойными кавычками*.

Как хранится в памяти текст? На самом деле для этого существует очень много кодировок текста:
- ASCII
- KOI8R
- Windows1251
- UTF8 / UTF16 / UTF32
- ...
В C++ для типа `char` используется очень простая кодировка `ASCII`. В этой кодировке самым основным символам предоставляется численный код от 1 до 127:
![](https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/ASCII-Table-wide.svg/875px-ASCII-Table-wide.svg.png)

Благодаря этой кодировке, `char` занимает в памяти только 1 байт. Но с помощью него нельзя хранить специальные символы, или символы из алфавитов разных языков.

Также стоит заметить, что в памяти компьютера `char` *хранится* так же, как `int` - в виде какого-то целого числа. Последовательность бит, в виде которой хранится в памяти переменная `char`, соответствует коду сивола в таблице `ASCII` в двоичной системе счисления.

Из-за этого значения типа `char` могут использоваться вместе с целыми числами:
```cpp
char a = 33; // В переменную a запишется символ с ASCII-кодом 33 ('!')
int b = a + 15; // здесь вместо a подставится ASCII-код лежащего там символа
char c = 'A' + 2; // запишем в c символ, находящийся в ASCII-таблице через 
// две строки после символа 'A'
```

У использования `char` есть некоторые минусы:
- Реализация `char` может различаться от одной ОС к другой. То есть, например, с `char` на `Linux` можно вывести русские символы, а в `Windows` нет.
- В `char` нельзя хранить специальные символы, как например иероглифы, эмодзи, специальные математические символы, и т.д.

Для решения второй проблемы существует отдельный тип - `wchar`, или же "широкий char".




Чтобы использовать какую-то конкретную кодировку, стоит использовать типы `char8_t`, `char16_t` и `char32_t` - символы в кодировках UTF-8, UTF-16 и UTF-32 соответственно.

Но! Стоит учитывать, что " шировкие" символы (wchar/char8_t/char16_t, char32_t) просто так не совмещаются с обычными char-ами, по очевидным причинам. Поэтому, например, нельзя вывести широкий символ при помощи `cout` - потребуется специальный поток для вывода широких выводов, `wcout`:
```cpp
wchar r = 'Р';
cout << r; // ошибка
wcout << r; // ОК
```
