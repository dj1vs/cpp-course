# Работа с разными типами данных

## Ключевое слово auto
В C++, начиная с С++11, существует ключевое слово auto. Оно позволяет не прописывать тип переменной при её создании и определять его автоматически из выражения, которое используется для инициализации переменной. 

Например:
```cpp
auto year = 1918;
```
Компилятор увидит справа целое число и заменит `auto` на `int`.

## У каждого выражения есть свой тип
В C++ с помощью *операндов* можно записывать простые и сложные выражения. И у каждого выражения, в свою очередь, тоже будет какой-то возвращаемый тип.

Например:
```cpp
auto sum = 1 + 2;
```

Справа от знака равенства записано выражение `1 + 2`. Здесь используется *операнд +*, который работает с двумя целыми числами. В этом случае всё очевидно: сумма двух целых чисел тоже будет целым числом, и компилятор успешно определит тип переменной `sum` как `int`.

Но какой тип будет у этой переменной?
```cpp
auto distance = 2 + 4.3;
```

В данном случае компилятор видит, что одно из чисел, принимаемых операндом `+` - дробное, и поэтому результат выражения тоже будет дробным, чтобы не потерять данных. Следовательно, тип переменной `distance` будет `float`.

### Классический пример с делением
И здесь мы сталкиваемся с достаточно распространённой ошибкой.

Взгляните на следующий код. Как думаете, какое здесь выведется число?
```cpp
std::cout << 5/2 << std::endl;
```

И `2.5` - это неправильный ответ! Потому что для выражения `5/2` компилятор определит тип по значениям 5 и 2. Все "входные" значения - целые числа, а значит и всё выражение тоже должно быть целым числом!

Поэтому `2.5` преобразуется в `int`, и мы увидим на экране число 2.

### Мораль
При составлении выражений всегда помните, что у них тоже есть конкретный тип данных, который компилятор будет угадывать по входным аргументам.

## Переполнение (overflow)
Если попытаться записать в переменную слишком большое значение, произойдёт переполнение.

Пример:
```cpp
char a = 300;
```

Тип `char` занимает в памяти только 1 байт, чего явно не хватит для числа 300.

### Что происходит в памяти при переполнении

Предположим, что в переменной `a` уже лежит число 127. В бинарном виде это будет выглядеть как:

`01111111`

Тип `char` *формально* может принимать и отрицательные значения, поэтому первый бит, по аналогии с `int`, равен 0.

Что же будет, если мы попытаемся к переменной `a` добавить ещё единицу? Результат в принципе будет предсказуем. Бинарное представление переменной будет выглядеть так:

`10000000`

Как видим, первый бит теперь равен 1 - а это для типа `char` это означает, что число отрицательное. Далее, за битом знака, идут только нули. `-0` автоматически переведётся в `-128`.

Получается, мы хотели в `char` положить `128`, а получилось, что там теперь лежит `-128`.

Аналогично, если мы попытаеимся в `char` положить заведомо слишком большое число, например `300`:

`100101100` -> `1[00101100]`

Квадратными скобками здесь я выделил часть числа `300`, которая непосредственно будет записана в переменную `char`. Таким образом, мы запишем в переменную не число `300`, а число \\( 101100_2 = 44_{10} \\).

## Приведение типов
Приведением типов называется операция, при которой значение одного типа *преобразуется* в значение другого.

### Расширяющее преобразование типов 
Мы уже рассматривали пример приведения типов в уроке про типы данных:
```cpp
char a = 33;
```

Так называется преобразование типов, при котором значение первого типа преобразуется в значение второго типа, размер которого меньше или равен первому.

Примеры:

```cpp
char a = 1;
int b = a;
long c = b;
long long d = c;
// ...
```

Думаю, логика понятна. Если мы в большую коробку положим маленькое значение, ничего плохого не произойдёт.

### Сужающее преобразование типов

А вот здесь уже начинаются проблемы.

При сужающем преобразованиии типов мы пытаемся значение *большого* типа данных преобразовать в значение *маленького* типа данных.

Наглядный пример:
```cpp
int a = 1;
char b = a;
```

Конкретно в этом коде проблем нет, потому что в `char` спокойно помещается единица.

Но в `int` может лежать и 1000, и -1234, и 2137000000. Если мы попытаемся положить такое значение в `char`, произойдёт переполнение данных (по той же схеме, что мы обсуждали ранее).

Такие ошибки очень сложно заметить и отловить. В нашем-то примере такое легко заметить, но что если значение переменной `a` вводится с консоли, а переменная `b` объявлена через 50 строк кода, или вообще в другой функции? 

## Явное преобразование типов
Бывают ситуации, когда мы чётко знаем, что хотим использовать значение одного типа как значение другого типа. С этим нам помогает *явное преобразование типов*.

Можно это реализовать двумя способами:
- Стиль C - `C-style cast`.
```cpp
int a = 33;
std::cout << (char)a << std::endl;
```

При таком подходе мы просто перед необходимым значением (в данном случае именем переменной) в скобках указываем нужный тип.

Такой синтаксис остался в С++ только для совиестимсоти с C. На самом деле так делать очень опасно, так как компилятор в данном случае **вообще** не отслеживает ошибки, которые могут возникнуть из-за подобного преобразования типов.
- Современный стиль - `static_cast<X>`
```cpp
int a = 33;
std::cout << static_cast<char>(a) << std::endl;
```
Использование абсолютно аналогичное, но при таком подходе мы на этапе компиляции увидим какие-то ошибки от компилятора, если с нашим конкретным преобразованием что-то не так.

## Пытаемся избежать ошибок с преобразованием типов

### Универсальная инициализация
В C++ есть специальный синтаксис, который позволяет строго отслеживать тип значения, который мы пытаемся положить в переменную при её инициализации:

```cpp
int a{13};
```

При такой инициализации компилятор защищает нас от:
- Неявного преобразования типов
- Возможного переполнения

То есть, следующий код вызовет ошибку:
```cpp
long long d = 1;
int a{d};
```

При использовании такой записи мы всё же можем использовать сужающее преобразование,
но **только если мы сами явно этого потребуем**:
```cpp
long long d = 1;
int a {static_cast<int>(d)};
```
### Не использовать С-style cast
Хоть синтаксис `(int)x` намного проще, чем `static_cast<int>(x)`, стоит понимать, что от него
в своё время отказались не просто так. При использовании `static_cast` компилятор дополнительно оберегает нас от проблем, связанных с неявными преобразованиями типов и переполнениями.

## Примеры неправильного обращения с типами данных из реальных проектов

Как я уже говорил, в истории человечества было множество примеров, когда неправильная работа с типами данных в С/C++ приводила к катастрофическим последствиям. Когда-то это были потерянные огромные суммы денег, когда-то это были реальные человеческие жертвы. Иногда это просто вызывало небольшой дискомфорт для пользователей программы, но всё равно критичность ошибки это сильно не меняет.

### Airane 5 
Крушение ракеты Airane 5. На запуск ракеты было потрачено более 300 миллионов долларов.

Причиной послужил `integer overflow` - 64-х битное число с плавающей точкой пытались запихнуть в 16-битный integer.

В источниках можно найти замечательную статью на хабре на эту тему и посмотреть видео крушения.

### Therac-25 
В 1985-1987 медицинской аппаратурлй Therac-25 смертельной дозой радиации были убиты 6-7 человек.

Причиной послужила неправильная работа с многопоточностью и возникший вследствие этого `integer overflow`.

На эту тему есть отличное видео-эссе, которое я оставил в источниках.

### Баги в видеоиграх
Очень много ошибок в видеоиграх, которые при желании очень легко нагуглить.

Наверное, самый легендарный пример - это сломанный экран в пакмане

![](https://upload.wikimedia.org/wikipedia/ru/1/1e/Pac-Man_screenshot_256_level.png)

Если играть достаточно долго, переменная с номер уровня переполняется, и экран уровня заполняется случайными символами, из-за которых пройти игру становится невозможно.

--- 
Справедливости ради должен отметить, что все эти примеры, мягко говоря, случились достаточно давно - но это не значит, что проблемы, описанные в этой статье, неактуальны.

Просто если их не учитывать, по уровню разработки вы откатитесь на 20-30 лет назад.

## Источники
1. [Статическая типизация и преобразования типов - Metanit](https://metanit.com/cpp/tutorial/2.4.php)
2. [Integer overlow - Wiki](https://en.wikipedia.org/wiki/Integer_overflow)
3. [Космическая ошибка: $370 000 000 за Integer overflow - Habr](https://habr.com/ru/companies/pvs-studio/articles/306748/)
4. [History's Worst Software Error - Youtube](https://youtu.be/Ap0orGCiou8)
5. [Ariane 5 rocket launch explosion - Youtube](https://youtu.be/PK_yguLapgA)