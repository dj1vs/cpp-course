# Последовательность преобразований

## Постановка проблемы

Зачастую, нам хочется использовать значения одного типа данных в качестве значений другого типа данных.

Взглянем на следующий код:

```cpp
double double_sum(double a, double b)
{
    return a + b;
}

int main()
{
    int a, b; std::cin >> a >> b;
    double_sum(a, b); // ?
}
```

У нас есть функция, которая возвращает сумму двух вещественных чисел типа `double`. Но в нашем коде мы используем две переменные типа `int`.

В принципе, никакая глобальная логика не сломается, если мы захотим вызвать `double_sum` для двух целых чисел.

И именно для таких ситуаций и работает последовательность преобразований.

## Как она работает
Если мы в контексте одного типа данных используем другой тип данных, компилятор автоматически будет пытаться преобразовать второй тип данных к первому.

В нашем примере, компилятор "под капотом" преобразует переменные `a` и `b` в тип `double`, и уже потом над значениями типа `double` произведёт нужные вычисления.

## Присваивание
Если мы будет присваивать значение типа A к переменной типа B, тоже будет выполняться последовательность преобразований:

```cpp
int a = 'd'; // char преобразуется в int
```

## Логические выражения
Наиболее наглядно последовательность преобразований можно отследить на примере *логических выражений*.

Подробнее про операции в целом смотри в отдельной статье.

```cpp
if (!(a % 5))
```

Что здесь происходит?
1. Имеем выражение в скобках - `a % 5`. Вычисляем его значение - предположим, это 3. Получится следующее "промежуточное" логическое выражение:
```cpp
if (!(3))
```
2. Оператор `!` принимает булево значение, поэтому произойдёт *полседовательность преобразований*, и число 3 преобразуется в булево значение (по очевидным правилам - если не 0, то `true`). Значение будет:
```cpp
if (!true)
```

... ну а дальше, думаю, понятно.

## Почему именно *последовательность*?
Потому что при наличии нескольких возможных типов для преобразования, компилятор будет искать наиболее подходящий.

Например, если оператор принимает либо `int`, либо `double` (например, оператор сложения `+`), а мы ему передадим `float` - компилятор преобразует этот тип именно к `double`, так как в данном контексте он больше подходит по смыслу.